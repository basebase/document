#### 线段树(Segment Tree)


##### 什么是线段树?

###### 线段树一些基础概念

* 注意点
  + 静态线段树[也就是我们的区间大小是固定的, 不会变化的] (这是我们学习的)
  +

* 基本概念
  + 线段树每个节点表示一个区间
  + 线段树的根节点表示整个区间统计范围, 如[1-N]
  + 线段树的每个叶子节点表示长度为1的元区间, 如[x, x]
  + 线段树的每个节点[l, r], 它的左子节点是[l, mid], 右子节点是[mid + 1, r], 其中 mid = (l + r) / 2

* 特性
  + 每个区间的长度是区间内整数的个数
  + 叶子节点为1, 不能再分
  + 叶子节点的数目和根节点表示的区间长度相同

* 基本操作
  + 区间更新
  + 区间查询
  + 扩展(取出区间最大值, 最小值, 区间值总和等)

* 应用场景  
  1. 比如给一组数据, 如: [1, 2, 3, 4], 有两种操作, 操作1: 给第i个数加上x, 操作2: 数组中最大的数是什么?

  上面的问题, 通过数组可以很方便的查询到最大值, 我们只需要遍历这个空间[start, end]即可找出最大值。  
  对于更新一个数, 我们就在这个数据上加上x, 如果A[i] = A[i] + x。使用数组实现该算法的缺点是什么呢?  

  Q1: Query查询最大值复杂度为O(n), 更新复杂度为O(1)

  在有Q个query的情况下这样总的复杂度为O(QN), 那么对于查询来说这样的复杂度是不能接受的, 在没学习线段树之前可能没有更好的方法进行优化。

  2. 下面两个例子[区间染色, 区间查询]

###### 为什么使用线段树
对于一类问题, 我们关心的是线段(或者区间)。

比如一个经典例子: 区间染色(如图1-1)

有一面墙, 长度为n, 每次选择一段墙进行染色。  
m次操作后, 我们可以看到多少种颜色?  
m次操作后, 我们可以在[i...j]区间内看到多少种颜色?

在这里, 染色操作就是我们的更新区间操作, 更新成了新的颜色。  
我们在[i...j]这个区间查看有多少种颜色, 这就是查询操作。

上述问题可以通过数组来完成, 但是更新和查询的时间都是O(n)级别的, 显然这个性能是不够的。 由于我们只关注某一个区间, 此时线段树就可以派上用场了。


图1-1
 ![1-1](https://github.com/basebase/img_server/blob/master/common/segment01.png?raw=true)


另一类经典问题: 区间查询(如图1-2)

之前我们都是针对单个元素进行插入、删除或者是更新操作。  
但是, 我们有些时候希望对一个区间内的所有数据进行统计查询。  
查询一个区间[i...j]的最大值, 最小值或者区间数字总和。(这就是基于一个区间的统计查询)

如: 我们现在要统计2017年注册用户截止当前消费最高的用户?消费最少的用户?


上述问题也可以使用数组来实现, 不过复杂度都是O(n)级别, 但是如果使用线段树的话则是O(logn)


图1-2
 ![1-2](https://github.com/basebase/img_server/blob/master/common/segment02.png?raw=true)


线段树解决以下问题:
  对于给定的区间[图1-2]
  1. 更新: 更新区间中一个元素或者一个区间的值
  2. 查询: 查询一个区间[i...j]的最大值, 最小值, 或者区间数字和。


对于上面这些问题, 我们说都可以通过线段树来现实会更加优秀快捷。
然鹅我们构建的线段树是一个静态的, 比如上面距离的区间染色, 我们就固定在0-15这个区间内进行染色更新, 而不会去考虑这个区间会新增(如0-20), 又比如说, 我们说2017年注册用户消费, 我们就设置定在2017年内固定这个区间值, 要更新也只是这个区间范围内的值, 而不是更新这个区间的大小。



###### 线段树的表示

我们利用数组来构建一个线段树, 如图[1-3]

 ![1-3](https://github.com/basebase/img_server/blob/master/common/segment03.png?raw=true)

以求和为例, 我们想查询[2...5]这个区间的和, 我们需要来到A[2...3]和A[4...5]这两个节点上, 并将这两个节点的结果进行合并。如此, 当数据量非常大的时候我们依然可以通过线段树非常快的找到我们关心的区间对应的一个或者多个节点进行操作, 而不需要对这个区间中所有元素进行遍历。
