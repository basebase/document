#### 字典树(Trie)


##### 什么是字典树?
字典树一般又被称为"前缀树"。

Trie通常只用来处理字符串。

Trie是一个多叉树。


假如现在有100万条数据, 如果使用Trie查找, 就和有多少条目没有关系。

|    数据结构    | 时间复杂度 |      备注 |
| -----------  |       --- |      --- |
| Trie         |      O(w) |    其中w为字符串长度
| BST          |   O(logn) |    


##### Tire数据结构

在考察一个字符串或者单词看成是一个整体, 但是Tire却打破了这种方式, 它以一个字母为单位拆分存储, 从根节点开始一直到叶子节点去遍历, 遍历到一个叶子节点就形成一个单词。

如图[1-1]中, 可以看到存储了4个单词, 分别是{"cat", "dog", "deer", "panda"}

图[1-1]
![1-1](https://github.com/basebase/img_server/blob/master/common/trie.png?raw=true)

我们要查询任何一个单词, 从根节点出发只需要经过这个单词有多少个字母, 过了多少个节点, 最终达到叶子节点。就成功查找到单词。这样的数据结构就叫做Trie。


###### Trie每一个节点是如何定义的？

由于我们的英文字母有26个, 所以每一个节点都有26个指向下一个节点的指针, 只不过我们图[1-1]中没有画那么多而已。

所以在Trie中节点大概定义如下
```java
class Node {
  char c ; // 每个节点装载一个字母
  Node[26] next ; // 装载26个指针
}
```

不过不同的场景下, 26个指针可能是富裕的, 有可能是不够的。
比如说, 每个节点下面跟26个孩子, 但是并没有考虑大小写的问题。如果我们设计的Trie要考虑大写的话, 相应的有52个指针。但是, 如果我们的Trie设计的更加复杂, 比如说装载了网址或者邮件地址, 相应的有一些字符也应该计算在内, 如: "@,:,\_-"等等。

所以通常并不会固定指针数量, 除非该场景固定就26个字母。  
所以我们需要<strong>每一个节点都有若干个指向下一个节点的指针。</strong>

```java

class Node {
  char c ;
  Map<char, Node> next ;
}
```

其实, 我们从根节点找到下一个节点的过程中, 我们就已经知道这个字母是谁了, 换句话说, 我从根节点来搜索"cat"这个词, 之所以能够来到这个节点, 是因为在根节点就知道我的下一个节点要到'c'所在的这个节点中。

所以, 在我们的设计中, 可以不存储这个字符

```java
class Node {
  Map<char, Node> next ;
}
```

不过上述的设计还是有问题, Trie从根节点一直到叶子节点才到了一个单词的地方。
比如我们查询到了't'我们就找到了"cat"这个词, 我们查询到了'g'我们就找到了"dog"这个词, 以此类推, <strong>不过在英语中有些单词可能是另外一个单词的前缀</strong>

比如说: "pan"这个单词, 如果我们这个Trie中既要存储"pan"又要存储"panda"那么怎么办呢? 此时这个"pan"它的结尾'n'并不是叶子节点, 正因为如此, 每一个节点都需要一个标识,这个标识来告诉大家当前这个节点是否是某一个单词的结尾, 某一个单词的结尾光靠叶子节点是无法区分出来的, 所以我们设计应该在加入一个字段代表是否为一个单词的结尾。

```java
class Node {
  boolean isWord ;
  Map<char, Node> next ;
}
```
