#### 并查集(union-find)


##### 什么是并查集?

并查集也是一种树结构, 它用于处理一些不交集的<strong>合并及查询问题。</strong>
以往的树结构都是父亲指向儿子, 而并查集是儿子指向父亲。

并查集支持下面两种操作:
  * 查找(find): 确定某个元素属于哪个子集。它可以被用来确定两个元素是否属于同一个子集。
  * 合并(Union): 将两个子集合并成一个子集。

<strong>也就是说，不支持集合的分离、删除。</strong>



先来说说<b>查找</b>究竟有什么用?   
举个例子: 几个家族进行宴会, 但是家族普遍长寿, 所以人数众多。由于长时间的分离以及年龄的增长, 这些人逐渐忘掉自己的亲人。只记得自己的爸爸是谁了。而最长者(称为"祖先")的父亲已经去世, 他只知道自己是祖先, 为了确定自己是哪个家族, 他们想出一个办法, 只要问自己的爸爸是不是祖先, 一层一层的往上问, 直到问到祖先。如果要判断两个人是否在同一个家族, 只要看两个人的祖先是不是同一个人就可以。

通过查找, 我们能清楚的知道两个人是否存在关系。 那么合并呢?

合并:  
宴会上, 一个家族的祖先突然对另外一个家族说: 我们两个家族交情这么好, 不如合成一家好了。另一个家族也欣然同意。


##### 并查集实现

##### 设计并查集接口
上面我们提到, 并查集只支持"查找"和"合并"两种操作, 所以我们接口中只设计该方法。

```java
public interface UF {

    // 并查集元素个数
    int getSize();

    boolean find(int p, int q);
    void union(int p, int q);
}
```


##### 并查集实现版本V1, Quick Find

现在我们要实现上面接口的实现, 一个是将两个元素合并在一起变成在一个集合中的元素(union), 另外一个就是检查两个元素是否是相连的(find)。

既然要判断是否所属同一个集合中或者合并元素进而同属于一个集合中, 所以我们可以在并查集内部数据做一个编号, 进而辨别。[如图1-1]

在这里0-9表示10个不同的数据, 当然这是一种抽象的表示, 具体可以想象这0-9这10个编号是10个人, 10部车或者10本书, 这都是更具具体业务来决定的。但是, 在并查集的内部我们只存储0-9这10个编号。它表示具体的10个元素。对于每一个元素并查集存储的是一个它所属于的集合ID。什么意思呢?

可以看到图[1-1]中, 元素[0, 2, 4, 6, 8]这几条数据所属的集合ID是0, 元素[1, 3, 5, 7, 9]所属的集合ID是1。

不同的ID值就是不同的集合所对应的编号。简单来说就是对这10条数据分成了2个集合。其中
[0, 2, 4, 6, 8]这6个元素在一个集合中, [1, 3, 5, 7, 9]这几个元素在另外一个集合中。


图[1-1]
![1-1](https://github.com/basebase/img_server/blob/master/common/unionFind01.png?raw=true)


从图[1-1]也能看出来, 其实就是利用数据来存储对应的id编号, 这种方式在查找中效率很高O(1), 但是在进行union的话就需要O(n)了。

比如说: 我现在要合并元素1和4, 可以看到元素1对应的集合id是1但是元素4对应的集合id是0, 在这种情况下, 将1和4这两个元素合并后, 1所属的集合和4所属的集合每一个元素相当于也连接了起来, 简单来说0和1的集合编号, 我们取其中一个进行覆盖让其都能关联在一起。

所以, 经过union之后, 就会变成图[1-2]这个样子

图[1-2]
![1-2](https://github.com/basebase/img_server/blob/master/common/unionfind02.png?raw=true)


```java
public class UnionFindV1 implements UF {

    private int[] id; // 集合编号

    public UnionFindV1(int size) {
        id = new int[size];

        /***
         * 在初始化的时候, 我们的元素都是独立的, 还没有某两个元素互相合并
         * 合并操作等我们构建好并查集之后进行union即可
         *
         * 现在我们初始化, 每个元素的编号都不一样
         *   第0个元素对应的集合编号是0
         *   第1个元素对应的集合编号是1
         *   ...依次类推
         *
         */
        for (int i = 0 ; i < id.length; i ++)
            id[i] = i;
    }

    @Override
    public int getSize() {
        return id.length;
    }

    @Override
    public boolean find(int p, int q) {

        /***
         * 首先查询p和q两个元素所属同一个集合编号
         *   O(1)查找
         */
        return find(p) == find(q);
    }

    // 查找元素p所对应的集合编号
    private int find(int p) {
        if (p < 0 || p >= id.length)
            throw new IllegalArgumentException("Error/");
        return id[p];
    }

    @Override
    public void union(int p, int q) {

        /***
         * 合并元素p和元素q所属的集合。
         *   需要循环所有元素进行替换O(n)
         */

        int pID = find(p);
        int qID = find(q);

        if (pID != qID) { // 这里只判断它们属于不同的集合中, 才进行合并。
            for (int i = 0; i < id.length; i++)
                if (id[i] == pID)
                    id[i] = qID;
        }
    }
}
```
