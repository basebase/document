### 递归

#### 递归介绍

***Q: 什么是递归函数***  
递归函数和我们编写的其它函数没有任何区别, 唯一不同的是它是自己调用自己, 这也是初学者在学习递归最难以理解的地方;

***Q: 如何理解递归&使用递归***  
递归方法就是把一个原问题分解为多个子问题, 并且这些子问题做着相同的处理(理解成这些子问题的都长得一模一样, 只不过体积越来越小了), 直到问题足够小不能再分解为止;  

注意: 这里把一个原问题转为更小的子问题时, 并不是简单的求一个更小子问题的答案, 而是更具这些更小子问题的答案构建出原问题的答案;

***总结一句话就是: 递归把一个原问题分解成多个子问题, 并通过这些子问题的结果去构建出原问题的答案;***

#### 递归三步走
1. 让递归有一个基本情况或者出口(即: 问题已经最小了, 在也无法分解), 否则我们的递归函数将一直调用直到内存溢出;
2. 递归函数必须更改其状态(也就是将原问题变成一个更小的问题), 并移至基本情况;
3. 函数必须是调用自身的;

#### 语言例子
最简单的就是电视上的广告, 每天重复的播放, 不断的播放, 只有当你听厌烦了转台或者关掉电视就结束了, 否则就是一直放, 一直放...直到电视坏掉;

#### 数组之和了解递归程序
上面已经大致了解递归算法的一个思想, 以及编写递归方法应该要注意的一些问题, 但是还是过于抽象, 下面通过一个数组累加的例子帮助大家快速了解递归程序;

假设现在我们有一组数据: [1, 3, 5, 7, 9], 我们想要把这一组数据进行累加, 并将结果返回去。
通常, 我们会使用一个循环来将一组数据进行累加, 但是现在假设我们没有循环可以使用, 我们如何去实现一组数据之和?

在编写一个函数之前我们最重要的明确函数要做什么功能, 递归函数也是如此, 所以现在我们现在要做的功能则是把整个数组中的数值累加并将结果返回;  

明确功能之后, 我们来分析如何编写递归程序:
1. 递归的最基本情况, 这里是一个数组, 也就是说当数组为空后我们需要终止递归函数;
2. 递归状态更改, 这里我们需要把数组缩小, 每个子问题处理的问题都比上一个问题更小, 从而达到第一种情况;
3. 需要一个返回结果, 把每个子问题的答案构建在一起, 给出原问题最终的答案;

明确了上面三个目标后, 具体如何实现呢?

```java
public class CalculatingNumbersSum {
    public int add(Integer[] numbers) {
        return add(numbers, 0);
    }
    private int add(Integer[] numbers, int index) {
        if (numbers.length == index)
            return 0;
        return numbers[index] + add(numbers, index + 1);
    }
    public static void main(String[] args) {
        Integer[] numbers = {1, 3, 5, 7, 9};
        System.out.println(new CalculatingNumbersSum().add(numbers));
    }
}
```

#### 删除链表元素
递归程序是非常适用于链表上的, 上面的数组之和只不过是让我们了解递归程序, 对于实际意义或许并不大, 下面这个实例则会比较有趣。

当前我们有下面一组链表数据  
![待删除的链表](https://github.com/basebase/document/blob/master/DataStructure/%E9%80%92%E5%BD%92/%E5%9B%BE%E7%89%87/%E5%BE%85%E5%88%A0%E9%99%A4%E7%9A%84%E9%93%BE%E8%A1%A8.png?raw=true)

现在我们想要把链表中元素为5的节点删除, 如何处理?

***Q: 删除链表元素思路***  
这里有两种思路:
1. 递归
2. 非递归

对于非递归删除链表元素的方式请参考 ***"链表数据结构这一章节"***, 这里重点描述递归方式删除

***Q: 递归方式删除思路***  
在编写递归函数之前, 首先明确下面一些问题:
1. 递归函数宏观语义(即: 这个函数要做什么功能, 只有明确功能才能更好的编写递归程序)
2. 递归的基本情况, 到哪里终止
3. 递归状态更改, 怎么缩小问题

希望大家在编写每一个递归程序时, 都能把前面三个问题想明白, 这样在编写递归程序时就不会太被动;

对于第一点, 我们要做的当然是删除指定元素的链表节点, 要做的功能就是删除一个节点;  
对于第二点来说则非常简单, 当链表为空的时候, 问题已经足够小, 可以直接获得到结果了;  
问题在于第三点, 如何去把原问题更小化, 并且根据这些更小化的的答案构建出原问题的解, 这一块则是最核心的逻辑, 请先看下图

![递归删除链表抽象图](https://github.com/basebase/document/blob/master/DataStructure/%E9%80%92%E5%BD%92/%E5%9B%BE%E7%89%87/%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E6%8A%BD%E8%B1%A1%E5%9B%BE.png?raw=true)

搞清楚两个问题:
1. 用户层调用
2. 递归层调用

用户层调用很好理解, 就是我们在main方法或者其它方法中调用另外一个方法, 也是我们的首次调用。头结点后面有完整的子链表(也是最初的原问题)。  
但当调用的是一个递归函数时, 我们会更改状态***头结点会更改为当前头结点的下一个节点, 与此同时新的头结点后面挂载的节点会越来越小***
而我们在递归过程中就是处理这些更小的链表, 删除相关元素, 余下没有被删除的节点;

当所有子问题都处理完后回到用户层(即第一次调用的地方), 我们需要检查当前头结点元素是否是要被删除的节点, 如果不需要删除则当前头结点挂载剩余节点, 否则只返回剩余节点;

下面, 我们通过代码实际看看如何通过递归删除链表中的元素
```java
public class RemoveElement {
    public static ListNode removeElements(ListNode head, int val) {
        if (head == null)
            return null;        // 基本情况, 链表为空

        ListNode node = removeElements(head.next, val);
        head.next = node;
        return head.val == val ? node : head;
    }
}
```