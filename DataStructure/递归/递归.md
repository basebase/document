### 递归

#### 递归介绍

***Q: 什么是递归函数***  
递归函数和我们编写的其它函数没有任何区别, 唯一不同的是它是自己调用自己, 这也是初学者在学习递归最难以理解的地方;

***Q: 如何理解递归&使用递归***  
递归方法就是把一个基础问题分解为多个子问题, 并且这些子问题做着相同的处理, 直到问题足够小不能再分解为止;  
并且这些分解成多个子问题的结果集能还原最终的基础问题的解;

***Q: 递归三步走***  
1. 确定函数是自己调用自己;
2. 让递归有一个出口(即: 问题已经最小了, 在也无法分解), 否则我们的递归函数将一直调用直到内存溢出;
3. 问题还能继续分解成更小的子问题, 继续递归;

#### 语言的例子
1. 现在我们有一个100 * 100土地, 我们把这一块土地看成是一个基础问题, 现在我们要按照2 * 2的大小来开辟一小块田地, 所以我们需要把100 * 100的土地切分
直到最后只有2 * 2的的土地在也不能切分;

2. 俄罗斯套娃, 当我们打开一个娃娃发现还有一个一模一样的小娃娃, 继续重复的操作直到打开的娃娃再也装不下娃娃;

#### 数组之和了解递归程序

假设现在我们有一组数据: [1, 3, 5, 7, 9], 我们想要把这一组数据进行累加, 并将结果返回去。
通常, 我们会使用一个循环来将一组数据进行累加, 但是现在假设我们没有循环可以使用, 我们如何去实现一组数据之和?

此时, 我们创建一个方法, 接收两个参数, 然后方法返回相加结果值, 之后把结果值在放入参数中和新的数组中的值进行累加, 则会是下面这种结果

```text
    total = (1 + (3 + (5 + (7 + 9))))
    total = (1 + (3 + (5 + 16))
    total = (1 + (3 + 21))
    total = (1 + 24)
    total = 25
```

如何把上面的想法通过Java程序来实现呢?

```java
public class CalculatingNumbersSum {
    public int add(Integer[] numbers) {
        return add(numbers, 0);
    }
    private int add(Integer[] numbers, int index) {
        if (numbers.length == index)
            return 0;
        return numbers[index] + add(numbers, index + 1);
    }
    public static void main(String[] args) {
        Integer[] numbers = {1, 3, 5, 7, 9};
        System.out.println(new CalculatingNumbersSum().add(numbers));
    }
}
```
编写递归程序最重要的两个点在于:
1. 处理当前子问题, 并将当前子问题在进行分解;
2. 检查当前子问题是否足够小, 如果不能再分解时候, 则需要提供一个出口退出;


下图是递归调用过程, 每次递归调用时都会解决一个较小的问题, 直到问题无法在减小的程度为止;
![递归调用过程](https://github.com/basebase/document/blob/master/DataStructure/%E9%80%92%E5%BD%92/%E5%9B%BE%E7%89%87/%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png?raw=true)

当我们的问题达到无法在减小的程度时, 我们开始将每个子问题的解决方案组合在一起, 直到解决了最初的问题为止。下图展示的是递归返回子问题结果并形成最终结果的过程;
![递归返回过程](https://github.com/basebase/document/blob/master/DataStructure/%E9%80%92%E5%BD%92/%E5%9B%BE%E7%89%87/%E9%80%92%E5%BD%92%E8%BF%94%E5%9B%9E%E8%BF%87%E7%A8%8B.png?raw=true)