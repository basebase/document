### 二分搜索介绍

#### 二分搜索树概念
二分搜索树也是一颗二叉树。但是二分搜索树也有自己的一些特性, 如下:
* 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
* 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值
* 每一棵子树也都是二分搜索树

通过下图可以更加直观的感受到二分搜索树的概念, 从根节点开始, 其左子树的值都小于根节点的值, 而右子树的值都大于根节点的值。

![二分搜索树概念图](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A6%82%E5%BF%B5%E5%9B%BE.png?raw=true)


#### 二分搜索树实战

##### 二分搜索树初始化
经过前面的学习, 我们已经了对树结构有了一定的认识以及对二分搜索树的特性也有了一定的了解, 现在通过代码来构建一个二分搜索树的类;

```java
public class BST<E extends Comparable<E>> {     // ①

    private class Node {
        Node left;      
        Node right;     
        E e;          

        public Node(Node left, Node right, E e) {
            this.left = left;
            this.right = right;
            this.e = e;
        }

        public Node(E e) {
            this(null, null, e);
        }
    }

    private Node root;     
    private int size;       

    public BST() {
        this.root = null;
        this.size = 0;
    }

    public int getSize() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }
}
```
我们只需要注意第①点即可, 我们传入泛型的类需要有可比较性, 如果类无法比较则会破坏二分搜索树的特性, 就会出现下面的情况:  
小于的节点值会放在右子树中, 大于的节点值放在左子树中  
所以我们需要限制传入的泛型类具有可比较性;


##### 二分搜索树插入节点
对于如何插入一个节点, 如果把上面特性搞明白的话, 我相信对于插入一个节点是非常容易理解的, 不过在这里, 我还是会通过动图让大家清楚的知道如何插入一个节点,
中间的一个查找过程, 以及挂载过程。

现在我们有一组数[50, 18, 20, 88, 77, 100], 我们要按照二分搜索树的特性进行插入, 暂时先不要往下看, 自己动手试着画一下是不是已经理解了;

1. 首先, 我们先从元素50开始, 由于当前的二分搜索树一个节点都没有, 因此50就成为了root(根)节点;
2. 继续下一个元素18, 发现比根节点50小, 进入左子树, 发现左子树是一棵空树, 因此18成为根节点的左孩子;
3. 继续下一个元素20, 发现比根节点50小, 进入左子树, 由于刚才18已经插入到了左子树中所以继续比较, 发现比18大, 因此挂载节点18的右孩子下;
4. 继续下一个元素88, 发现比根节点50大, 进入右子树, 发现右子树是一棵空树, 因此88成为根节点的右孩子;
5. 继续下一个元素77, 发现比根节点50大, 进入右子树, 由于刚才88已经插入到了右子树中所以继续比较, 发现比88小, 因此挂载节点88的左孩子下;
6. 继续下一个元素100, 发现比根节点50大, 进入右子树, 由于刚才88已经插入到了右子树中所以继续比较, 发现比88大, 因此挂载节点88的右孩子下;


***Q: 二分搜索树如何确定插入位置***  
其实对于插入的位置, 我们只需要理解被插入的元素从根节点进行判断, 小于元素进入左子树, 大于元素进入右子树。  
1. 如果要插入的节点小于当前节点并且当前节点左孩子为空则插入到当前节点的左孩子中。  
2. 如果要插入的节点大于当前节点并且当前节点右孩子为空则插入到当前节点的右孩子中。

基于上面的流程, 无论有多少节点, 都是从根节点开始比较然后与子树节点进行比较, 直到找到对应的位置;

![二分搜索树插入节点-1](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-1.gif?raw=true)

当一棵已存在多个节点的二分搜索树我们要插入元素[4, 15, 88]这三个元素, 依旧按照上面的流程进行查找并插入;

![二分搜索树插入节点-2](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-2.gif?raw=true)


现在我们具体来实现如何插入一个元素节点, 我们通过递归来完成插入操作
```java

/**
* 插入元素
* @param e
*/
public void add(E e) {
// if (root == null) {
//     root = new Node(e);
//     size ++;
// } else
//     add(root, e);

// 由于递归已经判断为空的情况, 所以不需要在上述情况下判断root节点是否为空
root = add(root, e);
}

/***
* 插入元素, 从节点node开始查找并插入
* @param node
* @param e
* @return
*/
private Node add(Node node, E e) {

if (node == null) {
    size ++;
    return new Node(e);
}

if (node.e.compareTo(e) > 0) {
    node.left = add(node.left, e);

//            Node addNode = add(node.left, e);
//            node.left = addNode;
} else if (node.e.compareTo(e) < 0) {
    node.right = add(node.right, e);

//            Node addNode = add(node.right, e);
//            node.right = addNode;
} else if (node.e.compareTo(e) == 0) {
    // 对于重复数据, 这里不考虑;
    return node;
}

return node;
}
```

##### 二分搜索树查询元素
对于查询操作几乎和插入的操作是一模一样的, 不同的只是一个是插入新节点, 一个是返回查找到的节点。  
但是, 在这里, 我还是想通过几张动态让大家更加直观的看见二分搜索树查找过程;

小于根节点的查找情况: 当我们查找元素"33"的时候会从左子树开始查找

![二分搜索树查找-1](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-1.gif?raw=true)

大于根节点的查找情况: 当我们查找元素"85"的时候会从右子树开始查找

![二分搜索树查找-2](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-2.gif?raw=true)

基于上面的理论, 我们可以很方便和高效的查找到最小元素和最大元素, 查找当前节点的左孩子直到叶子节点就是最小元素, 反之查找当前节点的右孩子直到叶子节点就是最大元素;

![二分搜索树查找-3](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-3.gif?raw=true)

![二分搜索树查找-4](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-4.gif?raw=true)


```java

/***
* 查找二分搜索树元素
* @param e
* @return
*/
public boolean find(E e) {
    return find(root, e);
}

/**
* 递归查找二分搜索树元素
* @param node
* @param e
* @return
*/
private boolean find(Node node, E e) {
if (node == null)
    return false;

if (node.e.compareTo(e) > 0) {
    return find(node.left, e);
} else if (node.e.compareTo(e) < 0) {
    return find(node.right, e);
} else /*(node.e.compareTo(e) == 0)*/ {
    return true;
}
}

/**
* 查找最小元素
* @return
*/
public E findMin() {
    Node n = findMin(root);
    return n.e;
}

/**
* 递归查找最小元素
* @param node
* @return
*/
private Node findMin(Node node) {
if (node.left == null)      // 已经到叶子节点, 即最小值
    return node;
    Node n = findMin(node.left);
    return n;
}

/***
* 查找最大元素
* @return
*/
public E findMax() {
    Node n = findMax(root);
    return n.e;
}

/**
* 递归查找最大元素
* @param node
* @return
*/
private Node findMax(Node node) {
if (node.right == null)         // 已经到叶子节点, 即最大值
    return node;
    Node n = findMax(node.right);
    return n;
}
```