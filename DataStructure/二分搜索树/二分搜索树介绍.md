### 二分搜索介绍

#### 二分搜索树概念
二分搜索树也是一颗二叉树。但是二分搜索树也有自己的一些特性, 如下:
* 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
* 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值
* 每一棵子树也都是二分搜索树

通过下图可以更加直观的感受到二分搜索树的概念, 从根节点开始, 其左子树的值都小于根节点的值, 而右子树的值都大于根节点的值。

![二分搜索树概念图](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%A6%82%E5%BF%B5%E5%9B%BE.png?raw=true)


#### 二分搜索树实战

##### 二分搜索树初始化
经过前面的学习, 我们已经了对树结构有了一定的认识以及对二分搜索树的特性也有了一定的了解, 现在通过代码来构建一个二分搜索树的类;

```java
public class BST<E extends Comparable<E>> {     // ①

    private class Node {
        Node left;      
        Node right;     
        E e;          

        public Node(Node left, Node right, E e) {
            this.left = left;
            this.right = right;
            this.e = e;
        }

        public Node(E e) {
            this(null, null, e);
        }
    }

    private Node root;     
    private int size;       

    public BST() {
        this.root = null;
        this.size = 0;
    }

    public int getSize() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }
}
```
我们只需要注意第①点即可, 我们传入泛型的类需要有可比较性, 如果类无法比较则会破坏二分搜索树的特性, 就会出现下面的情况:  
小于的节点值会放在右子树中, 大于的节点值放在左子树中  
所以我们需要限制传入的泛型类具有可比较性;


##### 二分搜索树插入节点
对于如何插入一个节点, 如果把上面特性搞明白的话, 我相信对于插入一个节点是非常容易理解的, 不过在这里, 我还是会通过动图让大家清楚的知道如何插入一个节点,
中间的一个查找过程, 以及挂载过程。

现在我们有一组数[50, 18, 20, 88, 77, 100], 我们要按照二分搜索树的特性进行插入, 暂时先不要往下看, 自己动手试着画一下是不是已经理解了;

1. 首先, 我们先从元素50开始, 由于当前的二分搜索树一个节点都没有, 因此50就成为了root(根)节点;
2. 继续下一个元素18, 发现比根节点50小, 进入左子树, 发现左子树是一棵空树, 因此18成为根节点的左孩子;
3. 继续下一个元素20, 发现比根节点50小, 进入左子树, 由于刚才18已经插入到了左子树中所以继续比较, 发现比18大, 因此挂载节点18的右孩子下;
4. 继续下一个元素88, 发现比根节点50大, 进入右子树, 发现右子树是一棵空树, 因此88成为根节点的右孩子;
5. 继续下一个元素77, 发现比根节点50大, 进入右子树, 由于刚才88已经插入到了右子树中所以继续比较, 发现比88小, 因此挂载节点88的左孩子下;
6. 继续下一个元素100, 发现比根节点50大, 进入右子树, 由于刚才88已经插入到了右子树中所以继续比较, 发现比88大, 因此挂载节点88的右孩子下;


***Q: 二分搜索树如何确定插入位置***  
其实对于插入的位置, 我们只需要理解被插入的元素从根节点进行判断, 小于元素进入左子树, 大于元素进入右子树。  
1. 如果要插入的节点小于当前节点并且当前节点左孩子为空则插入到当前节点的左孩子中。  
2. 如果要插入的节点大于当前节点并且当前节点右孩子为空则插入到当前节点的右孩子中。

基于上面的流程, 无论有多少节点, 都是从根节点开始比较然后与子树节点进行比较, 直到找到对应的位置;

![二分搜索树插入节点-1](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-1.gif?raw=true)

当一棵已存在多个节点的二分搜索树我们要插入元素[4, 15, 88]这三个元素, 依旧按照上面的流程进行查找并插入;

![二分搜索树插入节点-2](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-2.gif?raw=true)


现在我们具体来实现如何插入一个元素节点, 我们通过递归来完成插入操作
```java

/**
* 插入元素
* @param e
*/
public void add(E e) {
// if (root == null) {
//     root = new Node(e);
//     size ++;
// } else
//     add(root, e);

// 由于递归已经判断为空的情况, 所以不需要在上述情况下判断root节点是否为空
root = add(root, e);
}

/***
* 插入元素, 从节点node开始查找并插入
* @param node
* @param e
* @return
*/
private Node add(Node node, E e) {

if (node == null) {
    size ++;
    return new Node(e);
}

if (node.e.compareTo(e) > 0) {
    node.left = add(node.left, e);

//            Node addNode = add(node.left, e);
//            node.left = addNode;
} else if (node.e.compareTo(e) < 0) {
    node.right = add(node.right, e);

//            Node addNode = add(node.right, e);
//            node.right = addNode;
} else if (node.e.compareTo(e) == 0) {
    // 对于重复数据, 这里不考虑;
    return node;
}

return node;
}
```

##### 二分搜索树查询元素
对于查询操作几乎和插入的操作是一模一样的, 不同的只是一个是插入新节点, 一个是返回查找到的节点。  
但是, 在这里, 我还是想通过几张动态让大家更加直观的看见二分搜索树查找过程;

小于根节点的查找情况: 当我们查找元素"33"的时候会从左子树开始查找

![二分搜索树查找-1](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-1.gif?raw=true)

大于根节点的查找情况: 当我们查找元素"85"的时候会从右子树开始查找

![二分搜索树查找-2](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-2.gif?raw=true)

基于上面的理论, 我们可以很方便和高效的查找到最小元素和最大元素, 查找当前节点的左孩子直到叶子节点就是最小元素, 反之查找当前节点的右孩子直到叶子节点就是最大元素;

![二分搜索树查找-3](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-3.gif?raw=true)

![二分搜索树查找-4](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9F%A5%E6%89%BE-4.gif?raw=true)


```java

/***
* 查找二分搜索树元素
* @param e
* @return
*/
public boolean find(E e) {
    return find(root, e);
}

/**
* 递归查找二分搜索树元素
* @param node
* @param e
* @return
*/
private boolean find(Node node, E e) {
if (node == null)
    return false;

if (node.e.compareTo(e) > 0) {
    return find(node.left, e);
} else if (node.e.compareTo(e) < 0) {
    return find(node.right, e);
} else /*(node.e.compareTo(e) == 0)*/ {
    return true;
}
}

/**
* 查找最小元素
* @return
*/
public E findMin() {
    Node n = findMin(root);
    return n.e;
}

/**
* 递归查找最小元素
* @param node
* @return
*/
private Node findMin(Node node) {
if (node.left == null)      // 已经到叶子节点, 即最小值
    return node;
    Node n = findMin(node.left);
    return n;
}

/***
* 查找最大元素
* @return
*/
public E findMax() {
    Node n = findMax(root);
    return n.e;
}

/**
* 递归查找最大元素
* @param node
* @return
*/
private Node findMax(Node node) {
if (node.right == null)         // 已经到叶子节点, 即最大值
    return node;
    Node n = findMax(node.right);
    return n;
}
```

##### 二分搜索树遍历
所谓的遍历操作就是把二分搜索树中所有节点都访问一遍, 而我们上面的插入元素操作还是查询元素操作往往只关注树的一侧, 比根节点小就只会查询左子树反之查询右子树。而遍历操作则都需要顾及、
并且树的遍历方式有多种, 如: "前序遍历"、"中序遍历"、"后续遍历"以及"层序遍历"这么几种方式;

其中前序、中序和后序遍历, 改变的仅是节点的访问顺序, 下面总结一下:
1. 前序遍历: 先访问父节点, 在访问左子树节点最后访问右子树节点
2. 中序遍历: 先访问左子树节点, 在访问父节点最后访问右子树节点
3. 后序遍历: 先访问左子树节点, 在访问右子树节点最后访问父节点

###### 前序遍历
***Q: 什么是前序遍历***  
如果一颗二分搜索树不为空, 则先访问当前节点, 然后访问其左、右子树节点, 称为前序遍历;  
如果不明白的话, 可以简单记忆为 ***父节点-左子树-右子树***的遍历规则

假设有一组数据{5, 3, 6, 2, 4, 8}插入至二分搜索树后, 要进行前序遍历, 其遍历流程如下:

![二分搜索树-遍历-前序遍历](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.gif?raw=true)

通过动图可以看到, 当我们传入一个root节点后, 先访问root节点元素, 然后访问其左子树, 如果当前节点左子树为空后继续访问右子树, 直到返回根节点上继续遍历其右子树的节点数据;


```java

public void preOrder() {
    preOrder(root);
}

private void preOrder(Node node) {
    if (node == null)
        return ;
    System.out.println(node.e);     // 访问当前节点
    preOrder(node.left);            // 访问左子树
    preOrder(node.right);           // 访问右子树
}
```


###### 中序遍历

***Q: 什么是中序遍历***  
如果一颗二分搜索树不为空, 则递归访问左子树直至叶子节点, 访问当前节点, 并继续访问右子树, 称为中序遍历;  
如果不明白的话, 可以简单记忆为 ***左子树-父节点-右子树***的遍历规则

或许文字不是特别的直观, 我们还是通过{5, 3, 6, 2, 4, 8}这么一组数据动态的展示中序遍历是怎么执行的;

![二分搜索树-遍历-中序遍历](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91-%E9%81%8D%E5%8E%86-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.gif?raw=true)

中序遍历不会一开始就直接访问根节点, 而是直接从左子树一直向下递归执行, 直到叶子节点后, 我们在对其叶子节点进行访问, 当该操作结束后返回至父节点并对其父节点进行访问, 之后继续访问该节点的右子树;
所以, 输出的元素顺序则会是, {2, 3, 4, 5, 6, 8}, 观察发现使用中序遍历是一个排序后的结果输出, 这是为什么呢?

***Q: 中序遍历为什么是有序的?***  

![二分搜索树-中序遍历-2](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2.png?raw=true)

我们先看一下这张图, 变量X是左右子树的父节点, 而左孩子的值都是小于父节点的, 右孩子的值都是大于父节点的。如果把上面中序遍历的描述和动图弄明白后, 就不太难理解, 我们遍历直到左子树的叶子点后并访问也就是小于X的值, 并返回上一层即父节点并对其访问, 然后在访问父节点的右子树节点,
所以我们看到输出顺序是一个有序的输出;

```java
public void inOrder() {
    inOrder(root);
}
private void inOrder(Node node) {
    if (node == null)
        return ;
    inOrder(node.left);
    System.out.println(node.e);
    inOrder(node.right);
}
```


###### 后序遍历

***Q: 什么是后序遍历***  
如果一颗二分搜索树不为空, 则递归访问左子树直至叶子节点, 并继续访问右子树, 称为后序遍历;  
如果不明白的话, 可以简单记忆为 ***左子树-右子树-父节点***的遍历规则

对于后序遍历相信上面两种遍历已经明白的话, 理解这个是毫不费力的;

![二分搜索树-遍历-后序遍历](https://github.com/basebase/document/blob/master/DataStructure/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/%E5%9B%BE%E7%89%87/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.gif?raw=true)


```java
public void postOrder() {
    postOrder(root);
}
private void postOrder(Node node) {
    if (node == null)
        return ;
    postOrder(node.left);
    postOrder(node.right);
    System.out.println(node.e);
}
```