### flink入门-水位线传播

#### 水位线传播
经过前面两小结的学习, 已经对watermark(水位线)有一个大致的了解, 那么这一小节介绍水位线是如何在flink中传播的。

flink内部将水位线实现为一个特殊的记录, 它们可以通过算子任务进行接收和发送。任务内部的时间服务(time service)会维护一些计时器(timer), 它们依靠接收到水位线来激活。

这些计时器是由任务在时间服务内注册, 并在将来的某个时间点执行计算。

例如: 窗口算子会为每个活动窗口注册一个计时器, 它会在事件时间超过窗口的结束时间清理窗口状态。

所以, 当任务接收到一个水位线时会执行以下操作:
1. 基于水位线记录的时间戳更新内部事件时间时钟
2. 任务的时间服务会找出所有触发时间小于更新后事件时间的计时器。对于每个到期的计时器, 调用回调函数, 利用它来执行计算或者发出记录。(简单理解为当计时器时间小于事件时间就会触发窗口计算或者其它计算操作)
3. 任务将更新后的水位线发出(什么方式发出?)


前面, 我们通过图解watermark(水位线)知道如何更新watermark, 但那个是单个分区的, 单个分区我们只需要取最大的时间戳, 那么多个分区怎么办呢? 每个分区作为一个数据流都会包含带有时间戳的记录以及水位线, 最终以谁的为准?

下面通过一个例子详细介绍一下任务如何将水位线发送至多个输出任务, 以及它从多个输入任务获取水位线后如何推动时间时钟前进。


一个任务会为它的每个输入分区都维护一个分区水位线(partition watermark)。当收到某个分区传来的水位线后, 任务会将接收值和当前分区值进行比较, 选择较大的那个值去更新对应分区水位线的值。随后, 任务会把事件时间时钟调整为分区水位线中最小的值。

如果事件时间时钟向前推动, 任务会先处理因此而出发的所有计时器, 之后才会把对应的水位线以***广播***的形式发送至所有下游任务。

![flink水位线-传播](https://github.com/basebase/document/blob/master/flink/image/flink%E6%B0%B4%E4%BD%8D%E7%BA%BF/flink%E6%B0%B4%E4%BD%8D%E7%BA%BF-%E4%BC%A0%E6%92%AD.png?raw=true)

如上图, 展示了一个有4个输入分区和三个输出分区的任务, 步骤2中第一个分区更新为4(比当前水位线值要大, 进行更新), 然后更新事件时间时钟也就是要发送到下游任务的watermark选取4个分区中最小的值(即3)。

步骤3中, 单个分区进行更新watermark, 但是所有分区最小值还是3所以不更新事件时间时钟, 也不会广播发送给下游任务

直到步骤4更新单个分区后, 所有分区最小值为4进行更新然后进行发送。


但是, 这种设计有一个缺陷就是, 如果有两条或者多条输入数据流的算子, 如Union或Connect, 它们的任务同样是利用全部分区水位线中最小值来计算事件时间时钟, 并没有考虑到分区是否来自不同的输入流。

这就导致所有输入的记录都必须基于同一个事件时间时钟来处理。如果不同输入流的时间时间没有对齐, 就会导致一些问题。

所有分区都会持续提供自增的水位线, 但是只要有一个分区的水位线没有前进, 或分区完全空闲下来不在发送任何记录或水位线, 任务的事件时间时钟就不会前进, 继而导致计时器无法触发。这种情形会给那些靠时钟前进来执行计算或者清除状态的时间相关算子带来麻烦。
因此, 如果一个子任务没有以常规间隔接收新的水位线, 就会导致时间相关算子的处理延迟或者状态大小激增。

再比如有两个输入流的算子任务水位线差距很大时, 也会产生类似影响。对于一个有两个输入流的任务而言, 其事件时间时钟会受制于相对较慢的流, 而较快的流所记录的中间结果会在状态中缓存, 直到事件时间时钟到达允许处理它们那个点。

#### 总结
1. 单个分区选取最大值, 多个分区选取最小值。
2. 多条流任务需要注意每个数据分区状态, 避免没有数据导致watermark不前进, 拖累整体算子任务


